{-# LANGUAGE FlexibleInstances, OverloadedStrings #-}
module Utilities (Pretty(pretty, prettyPrint), simplify) where

-- WARNING: DO NOT EDIT THIS FILE FOR *ANY* REASON, ANY CHANGES WILL BE DISCARDED
--          YOU WILL BE PENALISED IF YOU CODE NO LONGER COMPILES.

-- You're NOT advised to spend any time dwelling on this file. The functions
-- pretty, prettyPrint, and simplify are explained in the spec, the
-- implementations are unimportant and obtuse.

import Prelude hiding (gcd)
import GHC.Real (Ratio((:%)), (%))
import Data.List (groupBy, sort, sortOn)
import Data.Ord (Down(Down))
import Data.Function (on)
import Data.String (IsString(..))

import Types

instance IsString (String -> String) where
  fromString = (++)

class Pretty a where
  -- this allows for an asymptotically more efficient pretty printing
  prettys :: a -> String -> String
  pretty :: a -> String
  pretty x = prettys x []
  prettyPrint :: a -> IO ()
  prettyPrint = putStrLn . pretty

instance Pretty Rational where
  prettys (a :% 1) = shows a
  prettys (a :% b)
    | a < 0 = "(-" . shows (abs a) . "/" . shows b . ")"
    | otherwise = "(" . shows a . "/" . shows b . ")"

instance Pretty Polynomial where
  prettys p = "[" . (foldr1 pm (map pretty p) ++) . "]"
    -- cannot difference list this, because of the need to
    -- inspect the head character, unfortunately
    where pm s1 ('-' : s) = s1 ++ " - " ++ s
          pm s1 "" = s1
          pm "" s = s
          pm s1 s = s1 ++ " + " ++ s
  prettyPrint p
    | null p' = putStrLn "[0]"
    | otherwise = putStrLn (pretty p')
    where p' = filter ((/= 0) . fst) p

instance Pretty Expr where
  prettys (P p) = prettys p
  prettys (Add e e') = prettys e
                     . if c == '-' then " - " . (s' ++) else " + " . (s ++)
    where s@(c : s') = pretty e'
  prettys (Mul e e') = prettys' e . " . " . prettys' e'
    where prettys' e@(Add _ _) = "(" . prettys e . ")"
          prettys' e = prettys e
  prettys (Pow e@(P [_]) n) = prettys e . "^" . prettys n
  prettys (Pow e n) = "(" . prettys e . ")^" . prettys n
  prettys (Log e@(P p)) = "log" . prettys e
  prettys (Log e) = "log (" . prettys e . ")"

instance Pretty Term where
  prettys (a, 0) = prettys a
  prettys (1 :% 1, n) = prettysPow n
  prettys (-1 :% 1, n) = "-" . prettysPow n
  prettys (a@(0 :% _), n) | n > 0 = ""
  prettys (a, n) = prettys a . prettysPow n

prettysPow :: Integer -> (String -> String)
prettysPow n
  | n < 2 = (replicate (fromInteger n) 'x' ++)
  | otherwise = "x^" . shows n

--------------------------
toExpr :: Rational -> Expr
toExpr n = P [(n, 0)]

isConstant :: Expr -> Bool
isConstant (P [(_, 0)]) = True
isConstant _ = False

isZero :: Expr -> Bool
isZero (P [(0, 0)]) = True
isZero _ = False

isOne :: Expr -> Bool
isOne (P [(1, 0)]) = True
isOne _ = False

gcd :: Rational -> Rational -> Rational
gcd r r' = gcd' (abs r) (abs r')
  where gcd' 0 r' = r'
        gcd' r 0 = r
        gcd' r r' = gcd' mn (mx - mn)
          where [mn, mx] = sort [r,r']

simplify :: Expr -> Expr
simplify = simplify' . factorise . simplify'

factorise :: Expr -> Expr
factorise e@(P p)    = factor e
factorise (Add e e') = Add e1 e2
  where [e1, e2] = sort' [factorise e, factorise e']
factorise (Mul e e') = Mul e1 e2
  where [e1, e2] = sort' [factorise e, factorise e']
factorise (Pow e n)  = Pow (factorise e) n
factorise (Log e)    = Log (factorise e)

sort' :: [Expr] -> [Expr]
sort' ps@[P p, P p']
  | less p p' = ps
  | otherwise = [P p', P p]
sort' ps = sort ps

less :: [Term] -> [Term] -> Bool
less ((c, e) : ps) ((c', e') : ps') = e <= e' && less ps ps'
less [] _ = True
less _ [] = False

factor :: Expr -> Expr
factor e@(P [(0, 0)]) = e
factor e@(P ts)
  | length ts' < 2 = P ts'
  | g == 1         = P ts'
  | otherwise      = Mul (toExpr g) (P [(c / g, n) | (c, n) <- ts'])
  where g = foldr1 gcd (map fst ts')
        ts' = filter (/=(0,0)) ts
factor e = e

simplify':: Expr -> Expr
simplify' (Add e e') = simplify'' (Add (simplify' e) (simplify' e'))
simplify' (Mul e e') = simplify'' (Mul (simplify' e) (simplify' e'))
simplify' (Pow e n)  = simplify'' (Pow (simplify' e) n)
simplify' (Log e)    = simplify'' (Log (simplify' e))
simplify' e         = e

normalise :: Polynomial -> Polynomial
normalise = map collapse . groupBy ((==) `on` snd) . sortOn (Down . snd)
  where collapse ts@((_, expo):_) = (sum (map fst ts), expo)

crs p1 p2 = normalise (biliftA2 (*) (+) <$> p1 <*> p2)

simplify'' :: Expr -> Expr
simplify'' (Add (P p1) (P p2)) = P (normalise (p1 ++ p2))
simplify'' (Add e e')
  | isZero e  = e'
  | isZero e' = e
simplify'' (Add (Mul e1 e2) (Mul e1' e2'))
  | isConstant e1, isConstant e1', e2 == e2' = Mul (simplify'' (Add e1 e1')) e2
simplify'' (Add (Log e) (Log e')) = Log (simplify'' (Mul e e'))
simplify'' (Mul e e')
  | isOne e   = e'
  | isOne e'  = e
  | isZero e  = toExpr 0
  | isZero e' = toExpr 0
simplify'' (Mul e@(P p1) (P p2))
  | not (isConstant e) = P (crs p1 p2)
simplify'' (Mul e1 (Mul e2 e3))
  | isConstant e1
  , isConstant e2 = simplify'' (Mul (P (crs (unP e1) (unP e2))) e3)
  | isConstant e2 = Mul e2 (simplify'' (Mul e1 e3))
simplify'' (Pow e (0 :% 1)) = toExpr 1
simplify'' (Pow e (1 :% 1)) = e
simplify'' (Pow (P p) (n :% 1))
  | n > 0 = P (foldr1 crs (replicate (fromInteger n) p))
simplify'' (Mul e (Pow e' n))
  | e == e' = Pow e' (n + 1)
simplify'' (Mul (P [(c, m)]) (Pow e'@(P [(c', 1)]) n)) =
  Mul (P [(c * c', 0)]) (Pow (P [(1, 1)]) (m % 1 + n))
simplify'' (Mul (Pow e m) (Pow e' n))
  | e == e' = Pow e (m + n)
  | m == n  = Pow (Mul e e') m
simplify'' (Log (Pow e n)) = Mul (toExpr n) (Log e)
simplify'' e = e

unP :: Expr -> Polynomial
unP (P p) = p
unP e = []

biliftA2 :: (a -> b -> c) -> (x -> y -> z) -> (a, x) -> (b, y) -> (c, z)
biliftA2 f g (u, v) (x, y) = (f u x, g v y)
